# fractals 
# oct 19 - oct 25, 2018
# by Eric Li
# source: Ms. Healey, Ethan Chapman, Tilden Jackson, StackExchange (https://math.stackexchange.com/questions/1099/mandelbrot-like-sets-for-functions-other-than-fz-z2c)
# on my honor

# this is a program that generates fractals with Pillow. 
# the program generates three fractal images (2 mandelbrot images and 1 fractal image created by sin functions.)
# the code automatically generates three images that are scaled images of the generic fractals.
# colors are assigned to the images with different algorithms

from PIL import Image
import random
import math
import colorsys

# defining all global variables for further use
constant = complex(0,0)
count = 0
coordinate_x = 0
coordinate_y = 0
coef_real = 0
coef_imag = 0

imgx, imgy = 1000, 1000			# the size of each image


# the function defines and runs through the Mandelbrot calculation for each pixel/number in each cell
# the funcion uses recursion to calculate the number of iterations it takes for each number in the cell to escape
# the base case of this recursion/the maximum number of iterations the function runs through before it is stopped is 255
# the escape radius is 2
# in the function if the absolute value of the complex number does not exceed or equal to 2 the function is run again with the new complex number being z^2 + c
# in this function c is named "constant," while z is the complex number
# the function returns the corresponding color parameters for each pixel/cell
# the inital whiteness of the returned color is directly proportional to the number of iterations, although most colors are altered before they are returned  
def mandelbrot_calc(n,z):			# input n allows for the function to be used multiple times for different images generated by the Mandelbrot calculation
	global constant, count, coordinate_x, coordinate_y
	
	if count >= 256:			# base case; stops the recursion
		return (0,0,0)			# the pixel is black

	elif abs(z) >= 2:			# if the value escapes
		if n ==	1:			# if the function is called in order to generate the first image
			return (360*math.sin(count),count%100,count**2%100)			# the function returns these values as the parameters for color
		else:			# if the function is called in order to generate the second image
			# the following line is a smoothing algorithm that creates a gradient across all color blocks
			count = count - math.log(math.log(abs(z)))/math.log(2)			# source: Ethan Chapman
			if count > 100:			# if the number escapes after being calculated for more than 100 times/if the intial returned color is expected to be brighter
				return (count-(coordinate_y/2), count+((coordinate_y-coordinate_x)/4), count+(coordinate_x/2))			# the function returns color parameters that eventually form a gradient based on the position of the pixel
			else:			# if the number escapes within 100 iterations/if the inital returned color is expected to be darker 
				return (count, count, count)			# the function returns color parameters that does not forms a gradient based on the position of the pixel

	count += 1			# records the number of iterations
	return mandelbrot_calc(n, z**2+constant)			# recursion



# the function defines and runs through the a fractal calculation, which uses the sin of a complex number, for each pixel/number in each cell
# the funcion uses recursion to calculate the number of iterations it takes for each number in the cell to escape
# the base case of this recursion/the maximum number of iterations the function runs through before it is stopped is 99
# the escape radius is 10pi
# in the function if the absolute value of the complex number does not exceed or equal to 10pi the function is run again with the new complex number being sin(z) + c
# specifically for the fractal calculation (since python does not have a buildin function for the sin of a complex number):
# 	1) sin(z) = sin(x + yi) = (sin(x)cosh(y), cos(x)sinh(y))
#	2) c in this case is split into x(the real number, expressed as "coef_real" in the function) and y(the imaginary coefficient, expressed as "coef_imag" in the function)
# the function returns the corresponding color parameters for each pixel/cell
# the idea comes from StackExchange (https://math.stackexchange.com/questions/1099/mandelbrot-like-sets-for-functions-other-than-fz-z2c)
# the inital whiteness of the returned color is directly proportional to the number of iterations, although most colors are altered before they are returned  
def fractal_sin_calc(a,b):
	global coordinate_y, coordinate_x, coef_real, coef_imag, count
	
	if count >= 100:			# base case; stops the recursion
		return (coordinate_y/4,coordinate_x*coordinate_y/4000, coordinate_x/4)			# the function returns color parameters that eventually form a gradient based on the position of the pixel

	elif ((a**2+b**2)**0.5) >= 10*math.pi: # if the value escapes
		return (count, count, count)			

	count += 1			# records the number of iterations
	return fractal_sin_calc(math.sin(a)*math.cosh(b) + coef_real, math.cos(a)*math.sinh(b) + coef_imag)			# recursion


# the main function that:
#	1) defines how much the image is zoom in/out
#	2) creates the for loop to check through each pixel/cell
#	3) althers the colors
#	4) shows the images
#	5) saves the images
def fractal(a):			# the input that allows for the function to be used by all images
	global constant, count, coordinate_x, coordinate_y, coef_real, coef_imag
	image = Image.new("RGB",(imgx,imgy))			# a new image is generated

	if a == 1:			# if the first image is being generated; the following lines are the scale
		xa, xb = -0.568396, -0.555822
		ya, yb = -0.647949, -0.637276

	elif a == 2:			# if the second image is being generated; the following lines are the scale
		xa, xb = 0.3025074005126953, 0.3064098358154297
		ya, yb = 0.021409034729003906, 0.02531147003173828

	else:			# if the third image is being generated; the following lines are the scale
		xa, xb = 1.8, 4.5
		ya, yb = -1.4, 1.4

	# the for loop that checks through every pixel/cell
	for y in range(imgy):
			cy = y * (yb-ya)/(imgy-1) + ya 		#the y value for the cell; calculated by evenly spacing out the interval
			coordinate_y = y
			for x in range(imgx):
				cx = x*(xb-xa)/(imgx-1) + xa 		#the x value for the cell; calculated by evenly spacing out the interval
				coordinate_x = x
				count = 0			# reset the number of iterations for each pixel/cell
				if a == 1:			# if the first image is being generated
					constant = complex(cx, cy)
					(h, l, s) = mandelbrot_calc(1,0)			# indicates that the function is run for the first image, and the initial z is 0
					# the following line suggests that the color parameters defined by the function is in the HSL color model
					(r, g, b) = colorsys.hls_to_rgb(h, l, s)			# it is translated back to the RGB model
					# in order to create a blue hue
					r = r % 45			# the red parameter cannot exceed 45
					g = g % 200			# the green parameter cannot exceed 200
				elif a == 2:		# if the second image is being generated
					constant = complex(cx, cy)
					(r, g, b) = mandelbrot_calc(2,0)			# indicates that the function is run for the second image, and the initial z is 0
				else:			# if the third image is being generated
					coef_real = cx
					coef_imag = cy
					(r, g, b) = fractal_sin_calc(0,0)
					# the following if statement makes sure that the filter does not apply to the middle pixels whose fractal calculations exceed the maximum number of iterations
					# because in function "fractal_sin_calc" there's already a color assigned to each of those pixels
					if count < 100:			# if the number in the cell escapes within 100 iterations/if pixel is not colored in function "fractal_sin_calc,"
						# the following algorithm allows for the function to assign color, other than white and grey, to each pixel while sticking to the original gradient pattern formed by these pixels
						for i in range(0, 256, 5):
							# as long as the program finds out where along the gradient the pixel falls into, it changes its color accordingly without disrupting the original overall gradient pattern 
							if r+g+b <= i:
								r -= 20*(i/5)
								g += 20*(i/7)
								b += 20*(i/3)
								break			#once that is done, the loops breaks so that it is not done to the same pixel twice
				image.putpixel((x, y),(int(r),int(g),int(b)))			# color is given to the pixel

	image.show()			# the prpgram shows the image 

	# the program saves the image accordingly
	if a == 1:
		image.save("fractal1.png", "PNG")
	elif a == 2:
		image.save("fractal2.png", "PNG")
	else: 
		image.save("fractal3.png", "PNG")



# each time the function is called the corresponding image is generated, shown, and saved
fractal(1)
fractal(2)
fractal(3)